#!/usr/bin/python
# -*- coding: utf-8 -*-
""" 
Creates a PC-BC network, producing gamma oscillation - generated by PING mechanism
The script is based on the NeuroML version of the model and aims to show easy reusability!
Authors: Andr√°s Ecker, Padraig Gleeson
"""

import opencortex.build as oc_build
# workaround to handle opencortex's way of including cell templates
import neuroml
from pyneuroml import pynml
import opencortex.core as oc


def add_pop(network, cell_type, pop_size, color):
    """adds population using opencortex function"""
    
    return oc.add_population_in_rectangular_region(network,
                                                   pop_id="pop_%s"%cell_type, cell_id="%scell"%cell_type,
                                                   size=pop_size,
                                                   x_min=0, y_min=0, z_min=0,
                                                   x_size=200, y_size=200, z_size=200,
                                                   color=color)
                                                   
                                                   
def add_proj(nml_doc, network, prepop, postpop, ncons, post_seg_group, weight_mult=1):
    """adds targeted projection using opencortex function"""
    
    import re
    precell = re.split(r'\_', prepop.id)[1]
    postcell = re.split(r'\_', postpop.id)[1]
    
    # Note: Opencortex extends the id of the given projection
    return oc.add_targeted_projection(nml_doc, network,
                                      prefix="proj_%spop_to_%spop"%(precell, postcell),
                                      presynaptic_population=prepop,
                                      postsynaptic_population=postpop,
                                      targeting_mode="convergent",
                                      synapse_list=["syn_%s_to_%s"%(precell, postcell)],
                                      number_conns_per_cell=ncons,
                                      pre_segment_group="soma_group",
                                      post_segment_group=post_seg_group,
                                      delays_dict={"syn_%s_to_%s"%(precell, postcell):3},
                                      weights_dict={"syn_%s_to_%s"%(precell, postcell):weight_mult})


def add_stim(nml_doc, network, prepop_name, postpop, avg_rate, ncons, post_seg_group):
    """adds input population with poisson firing rate using opencortex functions"""
    
    assert prepop_name in ["ca3", "ec"], "prepop name has to be 'ca3' or 'ec' for the synapse to work"
    
    import re
    postcell_type = re.split(r'\_', postpop.id)[1]
    
    if postcell_type == "poolosyn":
        # same as in "../synapses/exp2Synapses.synapse.nml", but stronger weight!
        syn = oc.add_exp_two_syn(nml_doc, id="syn_%s_to_%s_strong"%(prepop_name, postcell_type), 
                                 gbase="10.0nS", erev="0.0mV",  # stronger then the original 0.2nS
                                 tau_rise="0.5ms", tau_decay="3.0ms")  # ec and ca3 synapses have the same kinetics
    elif postcell_type == "pvbasket":
        # same as in "../synapses/exp2Synapses.synapse.nml", but stronger weight!
        syn = oc.add_exp_two_syn(nml_doc, id="syn_%s_to_%s_strong"%(prepop_name, postcell_type), 
                                 gbase="5.0nS", erev="0.0mV",  # stronger then the original 0.22nS
                                 tau_rise="2.0ms", tau_decay="6.3ms")
    
    pf_syn = oc.add_poisson_firing_synapse(nml_doc,
                                           id="pop_%s_to_%s"%(prepop_name, postcell_type),
                                           average_rate="%.2f Hz"%avg_rate,
                                           synapse_id="syn_%s_to_%s_strong"%(prepop_name, postcell_type))
    
    # Note: Opencortex extends the id of the given projection                                
    pf_proj = oc.add_targeted_inputs_to_population(network,
                                                   id="proj_%spop_to_%spop"%(prepop_name, postcell_type),
                                                   population=postpop,
                                                   input_comp_id=pf_syn.id,
                                                   segment_group=post_seg_group,
                                                   number_per_cell=ncons,
                                                   all_cells=True)
                                                   
    return pf_proj


def generate_PING_net(networkID, nPC=100, nBC=10,
                      generate_LEMS=True, duration=100, dt=0.025):
    """generates PC-BC network using methods above"""
    
    nml_doc, network = oc.generate_network(networkID, network_seed=12345, temperature="34degC")
    
    # include necessary files
    nml_doc.includes.append(neuroml.IncludeType(href="../cells/poolosyn.cell.nml"))
    # workaround to handle opencortex's way of including cell templates
    oc_build.cell_ids_vs_nml_docs["poolosyncell"] = pynml.read_neuroml2_file("../cells/poolosyn.cell.nml", include_includes=False)
    nml_doc.includes.append(neuroml.IncludeType(href="../cells/pvbasket.cell.nml"))
    oc_build.cell_ids_vs_nml_docs["pvbasketcell"] = pynml.read_neuroml2_file("../cells/pvbasket.cell.nml", include_includes=False)
    nml_doc.includes.append(neuroml.IncludeType(href="../synapses/exp2Synapses.synapse.nml"))
    
    # create populations
    pop_poolosyn = add_pop(network, "poolosyn", nPC, color="0 0 1")
    pop_pvbasket = add_pop(network, "pvbasket", nBC, color="1 0 0")
                                                       
    # add connections (hard coded for conndata_430.dat and syndata_120.dat)
    total_cons = 0
    # same all to all connectivity as in Traub et al. 1997
    proj_poolosynpop_to_pvbasketpop = add_proj(nml_doc, network,
                                               prepop=pop_poolosyn, postpop=pop_pvbasket,
                                               ncons=16, post_seg_group="apical_list_100_to_1000",
                                               weight_mult=20)
    total_cons += len(proj_poolosynpop_to_pvbasketpop[0].connection_wds)                                           
    proj_pvbasketpop_to_poolosynpop = add_proj(nml_doc, network,
                                               prepop=pop_pvbasket, postpop=pop_poolosyn,
                                               ncons=16, post_seg_group="soma_group",
                                               weight_mult=15)
    total_cons += len(proj_pvbasketpop_to_poolosynpop[0].connection_wds)                                           
    proj_pvbasketpop_to_pvbasketpop = add_proj(nml_doc, network,
                                               prepop=pop_pvbasket, postpop=pop_pvbasket,
                                               ncons=16, post_seg_group="soma_group",
                                               weight_mult=15)
    total_cons += len(proj_pvbasketpop_to_pvbasketpop[0].connection_wds)
    print("number of connections: %i (outer stimulation not included)"%total_cons)                                
    
    # add outer stimulation (# same rates as in Traub et al. 1997)

    proj_ca3_to_poolosyn = add_stim(nml_doc, network,
                                    prepop_name="ca3", postpop=pop_poolosyn,
                                    avg_rate=5, ncons=50, post_seg_group="dendrite_list_50_to_200")
    proj_ec_to_poolosyn = add_stim(nml_doc, network,
                                   prepop_name="ec", postpop=pop_poolosyn,
                                   avg_rate=5, ncons=50, post_seg_group="dendrite_list_200_to_1000")
    proj_ca3_to_pvbasekt = add_stim(nml_doc, network,
                                    prepop_name="ca3", postpop=pop_pvbasket,
                                    avg_rate=1, ncons=10, post_seg_group="dendrite_list_50_to_200")
                                            
    # save to file
    nml_fName = "%s.net.nml"%network.id
    oc.save_network(nml_doc, nml_fName,
                    validate=True, format="xml", use_subfolder=False)
    
    if generate_LEMS:
    
        # create plots for both population
        plots= {}
        max_traces = 16
        display_poolosyn = "Display_%s_v"%pop_poolosyn.id
        plots[display_poolosyn] = []
        display_pvbasket = "Display_%s_v"%pop_pvbasket.id
        plots[display_pvbasket] = []
        for i in range(0, max_traces):
            quantity_poolosyn = "%s/%i/%s/v"%(pop_poolosyn.id, i, pop_poolosyn.component)
            plots[display_poolosyn].append(quantity_poolosyn)
            quantity_pvbasket = "%s/%i/%s/v"%(pop_pvbasket.id, i, pop_pvbasket.component)
            plots[display_pvbasket].append(quantity_pvbasket)
        
        lems_fName = oc.generate_lems_simulation(nml_doc, network, nml_fName,
                                                 duration=duration, dt=dt,
                                                 gen_plots_for_all_v=False,
                                                 gen_plots_for_quantities=plots,
                                                 gen_saves_for_all_v=True,
                                                 gen_spike_saves_for_all_somas=True,
                                                 lems_file_name="LEMS_%s.xml"%network.id,
                                                 simulation_seed=12345)
                                                 
    else:
        lems_fName = None
        
    return lems_fName
                                 

if __name__ == "__main__":

    lems_fName = generate_PING_net("PINGNet", nPC=16, nBC=16, dt=0.01)
    
    run_simulation = True
    
    if lems_fName and run_simulation:
        oc.simulate_network(lems_fName, simulator="jNeuroML_NEURON",
                            max_memory="1G", nogui=False)
        # or use simulator="jNeuroML_NetPyNE", nogui=True, num_processors=mp.cpu_count()


